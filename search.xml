<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决 Git 中 fatal:refusing to merge unrelated histories]]></title>
    <url>%2F2019%2F09%2F17%2Ftroubleshooting%2Ffatal-refusing-to-merge-unrelated-histories%2F</url>
    <content type="text"><![CDATA[问题描述我们在没有 clone 的情况下，在本地 Init 了一个新的 Git Folder，在进行 push 操作时出现 fatal:refusing to merge unrelated histories 错误。 解决方法这个问题就是因为我们想要将两个不相关的 git history 合并到一起，git 默认是不允许的。我们可以在命令后添加： --allow-unrelated-histories 参数，使 git 不进行该检测。 例如： master/live 两个 branch 是不想关联的 branch， 我们可以使用以下命令将 master merge 到 live 中： 1234// switched to branch &apos;live&apos;$ git checkout live// merge &apos;master&apos; to &apos;live&apos;$ git merge master --allow-unrelated-histories]]></content>
      <categories>
        <category>TroubleShooting</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SmartGit 轻度破解，仅限个人使用]]></title>
    <url>%2F2019%2F09%2F17%2Ftroubleshooting%2Fregister-30-days-expire%2F</url>
    <content type="text"><![CDATA[SmartGit 个人使用时，可以免费试用 30 天，通过以下方法可以清楚之前 30 天的使用记录，从而达到长期使用的效果。^_^ smartGit 用于记录使用日期的文件是： %APPDATA%\syntevo\SmartGit\&lt;version_folder&gt;\settings.xml 所以我们只要找到它将他删除即可。 使用 运行（Windows + R)，输入 %APPDATA%\syntevo\SmartGit\ 定位到 SmartGit 目录, 选择相应的版本号（文件夹），在其中找到 settings.xml 将其删除即可。]]></content>
      <categories>
        <category>TroubleShooting</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>SmartGit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 学习笔记]]></title>
    <url>%2F2019%2F09%2F17%2Fstudy-notes%2Fnode-js%2F</url>
    <content type="text"><![CDATA[模块化Node 利用 JavaScript 的函数式编程特性，实现模块的隔离。 1(function() &#123; ... &#125;)(); 使用 module.exports = &lt;functionName&gt; 将函数暴露出去， 调用处用 require(&#39;&lt;module_name&gt;&#39;) 拿到暴露的函数。 基本模块fs文件系统模块 fs: 分为异步方法和*同步方法。 异步读文件: fs.readFile(&#39;&lt;FileName&gt;&#39;, &#39;utf-8&#39;, function(err, data){ ... }); 同步读文件: var data = fs.readFileSync(&#39;&lt;FileName&gt;&#39;, &#39;utf-8&#39;); 错误通过 try {...} catch() {...} 捕获。 异步写文件: fs.writeFile(&#39;&lt;FileName&gt;&#39;, data, function(err) { ... }); 传入的 data 是 String, 默认按 UTF-8 写入，传入的 data 是 Buffer, 则写入二进制文件。 同步写文件: fs.writeFileSync(&#39;&lt;FileName&gt;&#39;, data); 异步获取文件属性: fs.stat(&#39;&lt;FileName&gt;&#39;, function(err, stat) { ... }); 同步获取文件属性: var stat = fs.statSync(&#39;&lt;FileName&gt;&#39;); stream数据流读取/写入 fs.createReadStream, fs.createWriteStream 管道连接 readable.pipe(writeable, {end:true/false}); http http 模块 - 提供 request 和 response 对象 http.createServer(function(request, response) {...}); 创建 Web Server url 模块 - web 路径 path 模块 - 本地文件目录 cryptocrypto 提供 加密和哈希算法。 crypto.createHash(&#39;md5&#39;); - 哈希算法 MD5及SHA1 crypto.createHmac(&#39;sha256&#39;, &#39;secret-key&#39;); - 哈希算法 Hmac 需要额外的一个密钥 crypto.createCipher(&#39;aes192&#39;, &#39;secret-key&#39;); - AES 对称加密算法, 加解密用同一个密钥 crypto.createDiffieHellman(prime, generator); - DH 算法，密钥交换协议，双方在不泄露密钥的情况下生成一个密钥 crypto.create - 非对称算法，RSA 一个公钥和一个私钥构成密钥对 RSA 不适合加密大数据，对于大数据加密，先生成一个 AES 密钥加密大数据，然后用 RSA 加密 AES 密钥，实际使用时，传输 AES 和 RSA 2 份密钥。 Web 开发koa未完，待续 … 示例代码相关代码请参考：Node.js 示例代码。]]></content>
      <categories>
        <category>Study Notes</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 学习笔记]]></title>
    <url>%2F2019%2F09%2F17%2Fstudy-notes%2Fsql%2F</url>
    <content type="text"><![CDATA[SQL 简介SQL = Structured Query Language 总的来说，SQL语言定义了这么几种操作数据库的能力： DDL：Data Definition Language DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。 DML：Data Manipulation Language DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。 DQL：Data Query Language DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。 数据库类别 关系型数据库(SQL) 非关系型数据库(NoSQL) - MongoDB, Cassandra, Dynamo 关系模型主键主键是关系表中记录的唯一标识。选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。 123ALTER TABLE &lt;student&gt;ADD CONSTRAINT &lt;pk_id&gt;PRIMARY KEY (&lt;id&gt;); 外键外键是用来关联 2 个表结构的，表直接的约束分为以下 3 种： 一对一 一对多 - 外键建立在‘多’的表中(即从表) 多对多 - 需要建立中间表 创建外键 1234ALTER TABLE &lt;student&gt;ADD CONSTRAINT &lt;fk_class_id&gt;FOREIGN KEY (&lt;class_id&gt;)REFERENCES classes (&lt;id&gt;); 删除外键 12ALTER TABLE &lt;students&gt;DROP FOREIGN KEY &lt;fk_class_id&gt;; 索引索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。 12ALTER TABLE &lt;students&gt;ADD INDEX &lt;idx_name_score&gt; (&lt;name&gt;, &lt;score&gt;); 唯一索引 12ALTER TABLE &lt;students&gt;ADD UNIQUE INDEX &lt;uni_name&gt; (&lt;name&gt;); 约束根据业务要求，像身份号、手机号、邮箱地址等，它们具有业务含义不易作为主键，但是又具有唯一性：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一约束。 123ALTER TABLE &lt;students&gt;ADD CONSTRAINT &lt;uni_name&gt;UNIQUE (&lt;name&gt;); SQL 查询不带 FROM 子句的 SELECT 语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条 SELECT 1; 来测试数据库连接。 基本查询 - SELECT * FROM &lt;students&gt; 条件查询 - SELECT * FROM &lt;students&gt; WHERE id = 1 投影查询 - SELECT id, name FROM &lt;students&gt; 排序 - SELECT * FROM &lt;students&gt; ORDER BY id DESC NOTE: OREDER BY 要在 WHERE 条件后 分页查询 - SELECT * FROM &lt;students&gt; LIMIT &lt;10&gt; OFFSET &lt;0&gt; pageSize - LIMIT pageIndex - OFFSET=pageSize * (pageIndex - 1), pageIndex 从 1 开始，而 OFFSET 从 0 开始。 聚合查询 聚合函数：COUNT(), SUM(), AVG(), MAX(), MIN() 通过 GROUP BY 进行分组 SELECT &lt;class_id&gt;, &lt;gender&gt;, COUNT(*) num FROM &lt;students&gt; GROUP BY &lt;class_id&gt;, &lt;gender&gt;; 多表查询 - SELECT * FROM &lt;students&gt;, &lt;classes&gt;; 获得的集合为 A 表行数 * B 表行数 连接查询 内连接(INNER JOIN) 外连接(OUTER JOIN) 左连接(LEFT OUTER JOIN) 右连接(RIGHT OUTER JOIN) 全连接(FULL OUTER JOIN) INNER JOIN LEFT OUTER JOIN RIGHT OUTER JOIN FULL OUTER JOIN 两张表都存在的记录 左表存在的记录 右表存在的记录 左右表都存在的记录 SQL 修改关系数据库的基本操作就是增删改查，即 CRUD：Create、Retrieve、Update、Delete。 对于增、删、改，对应的SQL语句分别是： INSERT：插入新记录 - INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...); UPDATE：更新已有记录 - UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...; DELETE：删除已有记录 - DELETE FROM &lt;表名&gt; WHERE ...; 常用 SQL 语句数据库 + 表操作 SQL 语句 SQL 语句 含义 SHOW DATABASES 列出所有数据库 CREATE DATABASE 创建数据库 DROP DATABASE 删除数据库 USE 切换当前数据库 SHOW TABLES 列出所有表 DESC 查看表结构 SHOW CREATE TABLE 查看创建表的 SQL 语句 DROP TABLE 删除表 ALTER TABLE ADD COLUMN VARCHAR(10) NOT NULL 新增列 ALTER TABLE CHANGE COLUMN VARCHAR(20) NOT NULL 修改列属性 ALTER TABLE DROP COLUMN 删除列 EXIT 退出 MYSQL 连接 实用 SQL 语句 插入或替换 REPLACE INTO &lt;students&gt; (&lt;id&gt;, &lt;class_id&gt;, &lt;...&gt;) VALUES(&lt;1&gt;, &lt;1&gt;, &lt;...&gt;) 若 id=1 记录不存在，插入新纪录； 若 id=1 记录存在，当前 id=1 记录被删除，然后再插入新纪录。 插入或更新 INSERT INTO &lt;students&gt; (&lt;id&gt;, &lt;class_id&gt;, &lt;name&gt;, &lt;...&gt;) VALUES(&lt;1&gt;, &lt;1&gt;, &lt;&#39;xiao_min&#39;&gt;, &lt;...&gt;) ON DUPLICATE KEY UPDATE &lt;name&gt;=&lt;&#39;xiao_min&#39;&gt;, &lt;...&gt;; 若 id=1 记录不存在，插入新纪录； 若 id=1 记录存在，当前 id=1 记录被更新，更新字段有 UPDATE 指定。 插入或忽略 INSERT IGNORE INTO &lt;students&gt; (&lt;id&gt;, &lt;class_id&gt;, &lt;...&gt;) VALUES(&lt;1&gt;, &lt;1&gt;, &lt;...&gt;); 若 id=1记录不存在，INSERT 语句将插入新记录，否则，不执行任何操作。 快照 CREATE TABLE &lt;students_of_class1&gt; SELECT * FROM &lt;students&gt; WHERE &lt;class_id&gt;=&lt;1&gt;; 通过查询集合创建新表 事务操作多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些 SQL 一样，不会对数据库数据有任何改动。 BEGIN 开启一个事务 COMMIT 提交一个事务 ROLLBACK 回滚事务 隔离级别 脏读 DIRTY READ： 查询同一记录，2 次结果不一样，读到还未 commit 的数据结果； 不可重复读 NON REPEATABLE READ： 查询同一记录，2 次结果不一样，读到的结果在另一事务 commit/rollback 之间； 幻读 PHANTOM READ：查询同一记录，2 次结果是一样，但是会出现 事务 A 新增的列，事务 B 读不到(SELECT)，但是却可以更新(UPDATE)，更新后才可以读到。 ISOLATION LEVEL DIRTY READ NON REPEATABLE READ PHANTOM READ READ UNCOMMITTED YES YES YES READ COMMITTED - YES YES Repeatable Read - - YES Serializable - - - Serializable 虽然隔离级别最高，但是效率会大大下降。]]></content>
      <categories>
        <category>Study Notes</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记]]></title>
    <url>%2F2019%2F09%2F16%2Fstudy-notes%2Fjavascript%2F</url>
    <content type="text"><![CDATA[JavaScript 布局 通常 JavaScript 代码可以放到 &lt;head&gt; &lt;/head&gt; 中； 12345678910&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript"&gt; alert('Hello World'); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; type 默认属性即为：JavaScript, 所以可以不必显示指定。 将 JavaScript 代码放到单独的 .js 文件中； 12345678&lt;html&gt; &lt;head&gt; &lt;script src="/static/js/abc.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; JavaScript 基础比较运算符== ： 自动转换数据类型在比较；=== ： 如果数据类型不一致，返回 false； 字符串使用 `xxxxxxx` 标识多行字符串： 123console.log(`HelloWorld!`); 可以用 {$variable} 替换字符串中的变量： 123var name = 'Bob';var age = 20;console.log(`Hello, $&#123;name&#125;, you are $&#123;age&#125; years old!`); 对字符串的操作本身不会改变自身，而是返回一个新的字符串； str.toUpperCase() - 转变为大写str.toLowerCase() - 转变为小写str.indexOf(&#39;string&#39;) - 获取指定字符串出现的位置str.substring(startIndex, length) - 获取截取的字符串 数组通过索引进行赋值可以直接修改这个 Array： 123var arr = ['A', 'B', 'C'];arr[1] = 100;arr; //arr now is ['A', 100, 'C']; indexOf(value) - 搜索指定值的索引；slice(startIndex, length) - 类似于 String 的 substring()；push(&#39;value1&#39;, &#39;value2&#39;) - 末尾添加值；pop() - 删除最有一个值；sort() - 排序；reverse() - 反转数组；splice(startIndex, deleteNum, replaceValue1, replaceValue2) - 从指定的索引开始删除若干值，然后再从该位置添加若干值；concat(newArray) - 连接两个 Array;join(connectValue) - 每个值用指定的字符串连接，返回一个连接后的字符串 对象JavaScript 对象是动态类型，可以添加或删除属性; 1234567var person = &#123; name: 'David', age: '20',&#125;;person.gender = 'male'; // 新增 gender 属性delete person.age; // 删除 age 属性 使用 in/hasOwnProperty() 检测是否拥有某属性： in - 包括继承的属性, 例如： toString 是 object 对象的属性，结果也是 true;hasOwnProperty() - 必须是自身拥有的属性 1234'age' in person; //true'birth' in person; //falseperson.hasOwnProperty('age'); //trueperson.hasOwnProperty('toString'); //true 循环 for(i=index; i&lt;length; i++); for (var key in object); while(condition); do {...} while(condition); Map &amp; SetMap - 键值对集合； 12345var m = new Map([['David', 100], ['Bob', 10]]);m.get('David'); //100m.set('Adam', 99); //添加新的 key-valuem.has('Bob'); //truem.delete('Adam') //删除 key-'Adam' Set - Key 的集合，Key 不能重复，没有索引； 123var s = new Set([1, 2, 3, 3, '3']);s.add(4); // Set &#123;1, 2, 3, '3', 4&#125;s.delete(3); // Set &#123;1, 2, '3', 4&#125; iterable新的 iterable 类型，Array、Map 和 Set 都属于 iterable 类型。 for ... of 循环 解决 for ... in 循环的历史遗留问题: 1234567891011121314var a = ['A', 'B', 'C'];a.name = 'David';for (var i in a) &#123; console.log(i); // '0', '1', '2', 'name'&#125;for (var i of a) &#123; console.log(i); // 'A', 'B', 'C'&#125;a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值； // index：指向当前索引； // array：指向 Array 对象本身&#125;) 函数2 种定义方法： function abs(x) { ... } var abs = function(x) { ... }; 参数： arguments - 用于函数内部，指向传入的所有参数 ...rest - 指向传入的未显示指定的参数 function foo(a, b, ...rest){ ... } 作用域JavaScript 默认有一个全局对象 window，任何全局变量（函数也视为变量）都会绑定到 window 上。 var - 定义局部作用域变量let - 定于块级作用域变量 1234567891011function foo() &#123; for (let i=0; i&lt;100; i++) &#123; // &#125; i += 100; // SyntaxError; for (var i=0; i&lt;100; i++) &#123; // &#125; i += 100; // 仍然可以引用变量i&#125; const - 常量 解构赋值可以同时赋值多个变量，包括嵌套的数组： let [x, [y, z]] = [&#39;hello&#39;, [&#39;hi&#39;, &#39;welcome&#39;]]; 对象赋值： 12345678910111213141516var person = &#123; name: 'David', age: 20, gender: 'male', passport: 'G-12345678', address: &#123; city: 'Beijing', zipcode: '100001' &#125;&#125;;var &#123;name, address: &#123;city, zip&#125;&#125; = person;name; // 'David'city; // 'Beijing'zip; // undefined, 因为属性名是zipcode而不是zip// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:address; // Uncaught ReferenceError: address is not defined 高阶函数可以将函数作为参数传入： 123function add(x, y, abs) &#123; return abs(x) + abs(y);&#125; map 方法arr.map(function (x) { return abs(x); } ) - 依次对数组的每个元素调用指定的函数： 123456789function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5];arr.map(pow); // [2, 4, 9, 16, 25]arr.map(function (x) &#123; return x * x; &#125;); // [2, 4, 9, 16, 25]arr.map(x =&gt; x * x); // [2, 4, 9, 16, 25] reduce 方法arr.reduce(function (x, y) { return add(x, y); }) - 分别对数组的进行函数调用，依次往后累计： 1234var arr = [1, 2, 3, 4, 5];arr.reduce( function (x, y) &#123; return x + y; &#125;); // 15arr.reduce( (x,y) =&gt; x * y; ) // 15 filter 方法arr.filter(function (x) { return x&gt;99 }) - 通过返回值决定是否保留该元素 sort 方法arr.sort() - 默认排序按字符串 ASCII 码进行排序（eg. 10 &lt; 2） arr.sort(function(x,y) { if (x &lt; y) return -1; else if (x &gt; y) return 1; else return 0;}) - 修改排序规则则可以按照数字大小进行排序 sort 方法直接对当前 Array 进行修改。 every 方法判断 Array 中的每个元素是否满足条件 let r = arr.every(funciton (s) { return s.length &gt; 0;}); - 判断 Array 中是否存在空元素 find\findIndex 方法查找 Array 中满足条件的第一个元素\索引 let s = arr.find(function (s) { return s.toLowerCase() === s }); - 返回第一个小写的元素，如果未找到返回 undefinded foreach 方法用于遍历 Array, 没有返回值，也不会改变原 Array, 常用于遍历 arr.forEach(console.log) 闭包将函数作为结果返回。实现一个计数器的示例： 12345678function counter (initial) &#123; var x = initial || 0; return function() return x ++;&#125;var c = conter(100);c(); //100c(); //101 箭头函数1(x, y) =&gt; x * y; ==&gt; 等价于 ==&gt; 123function (x, y) &#123; return x * y;&#125; generator 生成器类似于在一个函数内可以返回多个结果 1234567891011function* name(max) &#123; var index = 0; while(index &lt; max) &#123; yield index++; &#125; return index;&#125;for (var x of name()) &#123; console.log(x);&#125; 标准对象number, string, boolean, function, underfined, object - (Array, null 均属于 object） Datevar date = new Date(2019, 6, 12); - 2019/07/12 JavaScript 的 Date 对象月份值从 0 开始，牢记 0=1 月，1=2 月，2=3 月，……，11=12 月。 RegExp正则表达式基础\d - 数字\w - 字母或数字\s - 空格 . - 任意字符* - 任意个字符(包括 0 个)+ - 至少一个字符? - 0 或 1 个字符{n} - n 个字符{n, m} - n~m 个字符 [] - 表示范围[0-9a-zA-Z] - 数字及字母A|B - A 或 B^ - 以…开头$ - 以…结尾 () - 定义组 RegExptest() 方法测试字符串是否符合正则表达式 1234var re = new RegExp('^\d&#123;3&#125;\-\d&#123;3-8&#125;$');var re = /^\d&#123;3&#125;\-\d&#123;3-8&#125;$/;re.test('010-12345'); // true exec() 方法提取正则表达式中定义的组, 失败返回 null 123var re = /^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/;re.exec('010-12345'); // ['010-12345', '010', '12345']re.exec('010 12345'); // null 123var re = /^[0-9a-zA-Z\.]+@.+\.\w+$/; // 匹配邮箱 v-tawe@microsoft.comvar re = /^\&lt;(.+)\&gt;\s+([0-9a-zA-Z\.]+@.+\.\w+)$/; // 匹配带名字的邮箱 &lt;David Tang&gt; v-tawe@microsoft.com JSON序列化 - JSON.parse(&#39;json&#39;)反序列化 - JSON.stringify(obj) 面向对象两种创建对象的方式： 通过数据类型对象创建： 12345678910111213141516var Student = &#123; name: 'Robot'; height: 1.2; run: function() &#123; return this.name + 'is running'; &#125;&#125;function createStudent(name) &#123; var s = Object.create(Student); s.name = name; return s;&#125;var xiaoming = createStudent('xiaoming');xiaoming.run(); //xiaoming is runing 通过构造函数实现： 123456789101112function Student(props) &#123; this.name = props.name || 'Robot'; this.height = props.height || '1.2';&#125;Student.prototype.run = function() &#123; return this.name + 'is running';&#125;function createStudent(props) &#123; return new Student(props || &#123;&#125;)&#125; 通过 class 实现： 123456789class Student &#123; constructor(name) &#123; this.name = name; &#125; run() &#123; return this.name + 'is running'; &#125;&#125; 原型继承定义新的构造函数，并在内部调用继承的构造函数的 call() 方法绑定this; 只有函数才有 prototype 属性, _proto_ 是所有对象都有的（包括函数）, 即对象原型 xxx.constructor。 通过构造函数实现继承： 1234567891011121314151617181920212223242526function inherits(Child, Father) &#123; var F = function()&#123;&#125;; F.prototype = Father.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125;function Student(props) &#123; this.name = props.name || 'unnamed'; this.height = props.height || 1.2;&#125;Student.prototype.run = function() &#123; return this.name + 'is running';&#125;function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125;inherits(PrimaryStudent, Student);PrimaryStudent.prototype.getGrade = function() &#123; return this.grade;&#125; 通过 class 实现继承： 12345678910class PrimaryStudent extends Student &#123; constructor(props) &#123; super(props); this.grade = props.grade || 1; &#125; getGrade() &#123; return this.grade; &#125;&#125; 浏览器需要支持 ES6 浏览器窗口： windows： windows.innerWidth; windows.innerHeight; 浏览器信息： navigator: navigator.appName; navigator.appVersion…; 屏幕信息： screen: screen.width; screen.height…; 当前页面 URL 信息: location: location.protocol; location.host…; DOM 对象: document: document.title; document.cookie…; document.getElementById(); - 根据 ID 获取 DOM 节点 document.getElementsByTagName(); - 根据 Tag 名词获取 DOM 节点 document.cookie - 获取 cookie 信息，服务器端使用 httpOnly 可以禁止 JS 读取 Cookie; 浏览器历史： history: history.back(); history.forward(); 历史遗留对象已弃用！！ DOM123456789101112131415161718192021222324252627282930313233var d = document.getElementById('id');document.getElementsByTagName('p');document.getElementsByClassName('class');document.querySelector('#id');document.querySelectorAll('div.class &gt; p');d.children; // 获取 id 下的所有子节点d.firstElementChild; // 获取 id 下的第一个子节点// 更新 DOMd.innerHTML = 'ABC &lt;span style="color:red"&gt;RED&lt;/span&gt; XYZ'; // 可以设置 HTML 标签d.innerText = 'ABC XYZ';//// 设置 CSSd.style.color = '#ff0000';d.style.fontSize = '20px';// 插入 DOMvar div1 = document.createElement('p');div1.id = 'div1';div1.innerText = 'DIV1';d.appendChild(div1);var ref = document.getElementById('ref');d.insertBefore(div1, ref);// 删除 DOMvar parent = d.parentElement;// 删除节点时 children 节点实时变化parent.removeChild(parent.children[0]); // 删除节点 0parent.removeChild(parent.children[0]); // 删除节点 1 表单没有 name 属性的表单控件不会提交。 表单控件 &lt;input type=&#39;text&#39;&gt;&lt;/input&gt; &lt;input type=&#39;password&#39;&gt;&lt;/input&gt; &lt;input type=&#39;radio&#39;&gt;&lt;/input&gt; &lt;input type=&#39;checkbox&#39;&gt;&lt;/input&gt; &lt;input type=&#39;hidden&#39;&gt;&lt;/input&gt; &lt;select&gt;&lt;/select&gt;&lt;/input&gt; 获取值 text, password, hidden, select 使用 value 获取值 select 使用 checked 获取值 文件&lt;input type=&#39;file&#39;&gt;&lt;/input&gt; AJAX只支持同源策略访问，跨域需要使用 CORS 策略。 创建 XMLHttpRequest 对象； 设置 onreadystatechange 回调函数； 通过 readyState === 4 判断请求是否完成； 根据 status === 2000 判断是否成功响应； 调用 open() 方法, 参数1： GET/POST; 参数2： URL 地址； 参数3：是否异步（默认 true); 调用 send() 方法发送请求； 1234567891011121314151617181920var request = new XMLHttpRequest(); // 新建 AJAX 对象// 状态发生变化时，函数被回调request.onreadystatechange = function() &#123; if (request.readyState === 4) &#123; // 成功 // 判断响应结果 if (request.status === 200) &#123; // 成功，responseText - 响应文本 return success(request.responseText); &#125; else &#123; // 失败 return fail(request.status); &#125; &#125;&#125;// 发送请求request.open('GET', '/api/categories');request.send(); Promise123456789101112131415161718192021222324function ajax(method, url, data) &#123; var request = new XMLHttpRequest(); return new Promise(function (resolve, reject) &#123; request.onreadystatechange = function() &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; resolve(request.responseText); &#125; else &#123; reject(request.status); &#125; &#125; &#125;; request.open(method, url); request.send(data); &#125;);&#125;var p = ajax('GET', '/api/categories');p.then(function(text) &#123; log.innerText = text;&#125;).catch(function(status) &#123; log.innerText ='ERROR' + status;&#125;) 并行执行： Promise.all()容错执行： Promise.race() 1234567891011121314151617var p1 = new Promise(function(resolve, reject) &#123; ...&#125;)var p2 = new Promise(function(resolve, reject) &#123; ...&#125;)// p1, p2 均执行成功后，执行 thenPromise.all([p1, p2]).then(function(results) &#123; console.log(results);&#125;)// p1, p2 同时执行，先执行成功的返回结果给 then，后执行成功的结果丢失Promise.race([p1, p2]).then(function(result) &#123; console.log(result);&#125;) JQuery 按 ID 查找： $(&#39;#id&#39;) 按 class 查找： $(&#39;.class&#39;) 按 Tag 查找： $(&#39;tag&#39;) 按属性查找： $(&#39;[name=email]&#39;); $(&#39;[type=password]&#39;) $(&#39;[name^=icon]): 查找 name 属性以 icon 开头的 DOM; $(&#39;[name$=with]&#39;): 查找 name 属性以 with 结尾的 DOM; 组合查找： $(&#39;input[name=email]&#39;); $(&#39;tr.red&#39;) 多项选择器： $(&#39;p, div&#39;); $(&#39;p.red, p.green&#39;); $(&#39;input[name=email],[name=password]&#39;) 选择器 层级选择器 用 空格 隔开： $(&#39;ul li.class&#39;) 子选择器 用 &gt; 隔开： $(&#39;ul &gt; li.class&#39;) 层级选择器 和 子选择器的区别在： 子选择器必须时父子关系，不可跨层级选择！ 过滤器 用 : 隔开： $(&#39;ul li:first-child&#39;); $(&#39;ul li:last-child&#39;); $(&#39;ul li:nth-child(2)&#39;); $(&#39;ul li:nth-child(even)&#39;) 表单相关 :input - &lt;input&gt;, &lt;textarea&gt;, &lt;select&gt;, &lt;button&gt; :file - input[type=file] :checkbox - input[type=checkbox] :radio - input[type=radio] :focus - 获取鼠标当前的焦点控件 input:focus :checked - 已选择的单选或复选框控件 input[type=radio]:checked :enabled - 可以正常输入的控件 :disabled - 已被禁用的控件 :visible - 可见的控件 :hidden - 隐藏的控件 … … 查找 &amp; 过滤 find() - 在所有子节点中进行查找 parent() - 从当前节点向上查找 next() &amp; prev() - 同一层级节点前后进行查找 filter() - 过滤掉不符合条件的节点 map() - 把一个 jQuery 对象包含的若干 DOM 节点转化为其他对象 first() &amp; last() &amp; slice(2, 4) - 截取 jQuery 对象 操作 text() &amp; html() - 获取或修改 text 或 html val() - 获取或修改 value 属性 css() - 获取或修改 css hide() &amp; show() - 隐藏或显示元素; 增加参数可以实现淡入淡出效果： hide(&#39;slow&#39;) / show(&#39;slow&#39;) attr() &amp; removeAttr() - 修改 DOM 属性 prop() - 与 attr() 类似 append() &amp; prepend() - 添加 DOM 节点 before() &amp; after() - 在当前元素前/后插入 DOM 节点 remove() - 删除节点 事件绑定事件： $(&#39;#id&#39;).on(&#39;click&#39;, function() { alert(&#39;Hello, World&#39;); }); $(&#39;#id&#39;).click(function() { alert(&#39;Hello, World&#39;); }); 事件类型： click - 单击 dblclick - 双击 mouseenter - 鼠标移入 mouseleave - 鼠标移除 mousemove - 鼠标在 DOM 内移动 hover - mouseenter + mouseleave keydown - 键盘按下 keyup - 键盘松开 keypress - 按一次键触发 focus - DOM 获得焦点 blur - DOM 失去焦点 change - DOM 内容变更 submit - form 提交 ready - 页面载入并且 DOM 树初始化后 仅作用于 document 对象 $(document).ready(function() {...}); 简化后： $(function() {...}); off(&#39;click&#39;, &lt;functionName&gt;) 取消事件绑定 动画效果 show(&#39;slow&#39;) / hide(&#39;slow&#39;) / toogle(&#39;slow&#39;) - 左上角缓慢收缩 slideUp(&#39;slow&#39;) / SlideDown(&#39;slow&#39;) / slideToogle(&#39;slow&#39;) - 垂直缓慢收缩 fadeIn(&#39;slow&#39;) / fadeOut(&#39;slow&#39;) / fadeToggle(&#39;slow&#39;) - 淡入淡出 animate() - 自定义效果 12345$('#id').animate(&#123; opacity: 0.25, width: 0px; height: 0px;&#125;, 1000, function() &#123; console.log('Complete'); &#125;).delay(1000).animate(...); 可以使用 delay() 实现动画的暂停。 AJAX $.ajax(async, method, contentType, data, headers, dataType) $.ajax(async, method, contentType, data, headers, dataType, jsonp:&#39;callback&#39;, jsonpCallback:&#39;callbackFunction&#39;, success: function(data){...}) $.get(url) $.post(url, data) $.getJSON(url) 扩展 使用 $.fn 绑定函数 使用 return this 实现链式调用 插件有默认值，绑定在 $.fn.&lt;pluginName&gt;.defaults 上 用户在调用时可传入参数以覆盖默认值 12345$.fn.&lt;pluginName&gt; = function(options) &#123; var bgcolor = options &amp;&amp; options.bgcolor || '#FFFFFF'; this.css('background', bgcolor) return this;&#125; extend(target, obj1, obj2, ...) 会将靠后对象的值合并到第一个 target 中, 越往后面的对象优先级越高； extend({}, $.fn.&lt;pluginName&gt;.defaults, options) 异常处理使用 try {...} catch {...} finally {...} 捕获 注意：异步操作时的异常无法在调用处捕获，同样，对于控件的事件处理，在绑定事件的代码处无法捕获事件处理函数的异常。 unerscore与 jQuery 类似，提供一套完善的 API, 绑定到 _ 变量上。 Collectionsmap/filter类似于 Array 的 map/filter 方法 _.map(object, function(value, key) {...}); _.mapObject(object, function(value, key) {...}); _.filter(object, function(value, key) {...}); every/some集合中元素都满足情况，_.every() 返回 true, 集合中部分元素满足情况， _.some() 返回 true _.every([1, 4, 7, -3, -9], (x) =&gt; x &gt; 0); // false _.some([1, 4, 7, -3, -9], (x) =&gt; x &gt; 0); // true max/min集合时 Object，会忽略掉 key，只比较 value _.max({ a: 1, b: 2, c: 3 }); // 3 groupBy_.groupBy([1, 2, 3, 4, 5], (x) =&gt; { if(x&lt;3) return &#39;small&#39;; else return &#39;big&#39; }); 更多 underscrore 方法。]]></content>
      <categories>
        <category>Study Notes</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 学习笔记]]></title>
    <url>%2F2019%2F09%2F16%2Fstudy-notes%2Fgit%2F</url>
    <content type="text"><![CDATA[Git 介绍 Git 是分布式版本控制系统 集中式 VS 分布式，SVN VS Git SVN 和 Git 主要的区别在于历史版本维护的位置; Git 本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史而 SVN 的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行; 这样的好处在于： 自己可以在脱机环境查看开发的版本历史。 多人开发时如果充当中央仓库的 Git 仓库挂了，可以随时创建一个新的中央仓库然后同步就立刻恢复了中央库。 Git 命令Git 配置12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; git config命令的--global参数，表明这台机器上的所有 Git 仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和邮箱地址。 创建版本库初始化一个 Git 仓库1$ git init 添加文件到 Git 仓库包括两步： 12$ git add &lt;file&gt;$ git commit -m "description" git add可以反复多次使用，添加多个文件，git commit可以一次提交很多文件，-m后面输入的是本次提交的说明，可以输入任意内容。 查看工作区状态1$ git status 查看修改内容1$ git diff 1$ git diff --cached 1$ git diff HEAD -- &lt;file&gt; git diff 可以查看工作区(work dict)和暂存区(stage)的区别 git diff --cached 可以查看暂存区(stage)和分支(master)的区别 git diff HEAD -- &lt;file&gt; 可以查看工作区和版本库里面最新版本的区别 查看提交日志1$ git log 简化日志输出信息 1$ git log --pretty=oneline 查看命令历史1$ git reflog 版本回退1$ git reset --hard HEAD^ 以上命令是返回上一个版本，在 Git 中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本是HEAD^^，往上 100 个版本写成HEAD~100。 回退指定版本号1$ git reset --hard commit_id commit_id 是版本号，是一个用 SHA1 计算出的序列 工作区、暂存区和版本库工作区：在电脑里能看到的目录；版本库：在工作区有一个隐藏目录.git，是 Git 的版本库。Git 的版本库中存了很多东西，其中最重要的就是称为 stage（或者称为 index）的暂存区，还有 Git 自动创建的master，以及指向master的指针HEAD。进一步解释一些命令： git add实际上是把文件添加到暂存区 git commit实际上是把暂存区的所有内容提交到当前分支 撤销修改丢弃工作区的修改1$ git checkout -- &lt;file&gt; 该命令是指将文件在工作区的修改全部撤销，这里有两种情况： 一种是 file 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是 file 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态。 丢弃暂存区的修改分两步： 第一步，把暂存区的修改撤销掉(unstage)，重新放回工作区： 1$ git reset HEAD &lt;file&gt; 第二步，撤销工作区的修改 1$ git checkout -- &lt;file&gt; 小结： 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- &lt;file&gt;。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了第一步，第二步按第一步操作。 已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，前提是没有推送到远程库。 删除文件1$ git rm &lt;file&gt; git rm &lt;file&gt;相当于执行 12$ rm &lt;file&gt;$ git add &lt;file&gt; 进一步的解释Q：比如执行了rm text.txt 误删了怎么恢复？A：执行git checkout -- text.txt 把版本库的东西重新写回工作区就行了Q：如果执行了git rm text.txt我们会发现工作区的 text.txt 也删除了，怎么恢复？A：先撤销暂存区修改，重新放回工作区，然后再从版本库写回到工作区 12$ git reset head text.txt$ git checkout -- text.txt Q：如果真的想从版本库里面删除文件怎么做？A：执行git commit -m &quot;delete text.txt&quot;，提交后最新的版本库将不包含这个文件 远程仓库创建 SSH Key1$ ssh-keygen -t rsa -C "youremail@example.com" 关联远程仓库1$ git remote add origin https://github.com/username/repositoryname.git 关联多个远程仓库1$ git remote add upstream https://github.com/username/repositoryname2.git 推送到远程仓库1$ git push -u origin master -u 表示第一次推送 master 分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。 从远程克隆1$ git clone https://github.com/usern/repositoryname.git 分支创建分支1$ git branch &lt;branchname&gt; 查看分支1$ git branch git branch命令会列出所有分支，当前分支前面会标一个*号。 切换分支1$ git checkout &lt;branchname&gt; 创建+切换分支1$ git checkout -b &lt;branchname&gt; 合并某分支到当前分支1$ git merge &lt;branchname&gt; 删除分支1$ git branch -d &lt;branchname&gt; 查看分支合并图1$ git log --graph 当 Git 无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用git log --graph命令可以看到分支合并图。 普通模式合并分支1$ git merge --no-ff -m "description" &lt;branchname&gt; 因为本次合并要创建一个新的 commit，所以加上-m参数，把 commit 描述写进去。合并分支时，加上--no-ff参数就可以用普通模式合并，能看出来曾经做过合并，包含作者和时间戳等信息，而 fast forward 合并就看不出来曾经做过合并。 保存工作现场1$ git stash 查看工作现场1$ git stash list 恢复工作现场1$ git stash pop 丢弃一个没有合并过的分支1$ git branch -D &lt;branchname&gt; 查看远程库信息1$ git remote -v 在本地创建和远程分支对应的分支1$ git checkout -b branch-name origin/branch-name， 本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联1$ git branch --set-upstream branch-name origin/branch-name； 从本地推送分支1$ git push origin branch-name 如果推送失败，先用 git pull 抓取远程的新提交； 从远程抓取分支1$ git pull 如果有冲突，要先处理冲突。 标签tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。 新建一个标签1$ git tag &lt;tagname&gt; 命令git tag &lt;tagname&gt;用于新建一个标签，默认为 HEAD，也可以指定一个 commit id。 指定标签信息1$ git tag -a &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息。 PGP 签名标签1$ git tag -s &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用 PGP 签名标签。 查看所有标签1$ git tag 推送一个本地标签1$ git push origin &lt;tagname&gt; 推送全部未推送过的本地标签1$ git push origin --tags 删除一个本地标签1$ git tag -d &lt;tagname&gt; 删除一个远程标签1$ git push origin :refs/tags/&lt;tagname&gt; 忽略特殊文件通过 .gitignore 文件控制追踪的文件。 Template： https://github.com/github/gitignore 命令别名1git config --global alias.&lt;alias&gt; &lt;fullName&gt; --global 表明针对当前用户，如果不加，则只对当前仓库起作用，配置文件 config 在 .git/config 文件中。 好用的 git log alias: git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot; 搭建 Git 私有仓库 搭建 Git 服务器 要方便管理公钥，用 Gitosis； 要像 SVN 那样变态地控制权限，用 Gitolite Git Cheat Sheet]]></content>
      <categories>
        <category>Study Notes</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
